## IP란?

- 인터넷 주소 체계로, 핵심 기능은 기기 간 정보 패킷을 전달하는 것이다.
- IP는 패킷 순서나 에러 체크를 하지 않는다. 이를 위해서 다른 프로토콜이 필요한데, 주로 TCP가 그 역할을 한다.

## TCP와 IP의 관계

- IP와 함께 쓰이며, IP는 데이터를 배달하는 역할이라면, TCP는 패킷을 추적 및 관리한다.
- 둘의 관계는 퍼즐에 편지를 써서 보내는 것과 비슷하다. 메시지는 각각의 퍼즐 조각들로 쪼개져서 서로 다른 경로로 배달될 수 있다. 그래서 도착했을 때 순서가 뒤죽박죽일 수도 있다.
  여기서 일단 조각들이 **모두 목적지 주소에 확실히 도착하도록 하는 게 IP**, 도착한 조각들을 순서에 맞게 맞추고 분실된 조각은 다시 보내달라고 요청하기도 하며, 발송자에게 수신 완료 사실을 알리는 역할을 하는 것이 TCP이다. 따라서 **TCP는 퍼즐 조각이 발송되기 전, 발송 완료 후에도 발송자와 연결되어 있다**고 이해할 수 있다.
- IP만으로는 목적지(target device)에 잘 수신되었는지 알 수 없기 때문에 TCP는 송수신자간 패킷이 순서에 맞게 잘 도착했는지 확인해주는 것!

## 흐름 제어

<img src="https://velog.velcdn.com/images/urjimyu/post/3a75dbc4-3878-4cf0-b3a5-2e51189979e1/image.png" width="400" height="300"/>


- 흐름 제어란 수신자 촉에 ACK를 받지 않은(즉 승인 받지 않은 상태로) 채 **많은 데이터를 보내는 것을 제어하기 위한 방법**이다. 수신자가 과도하게 많은 데이터를 받지 않도록 한다. 송신자와 수신자의 속도를 맞춰준다고 할 수 있다. OSI 계층 구조 중에서 data link 계층이 흐름 제어를 돕는다.

- 예를 들어 민아가 수업을 듣는데 채 이해를 하기도 전에 선생님이 많은 양의 새로운 개념들을 빠르게 가르친다고 하자. 민아는 사실상 이해한 것이 거의 없을 것이다. 따라서 선생님은 민아가 **한 번에 몇 가지 개념까지 이해할 수 있는지 파악**하고 있어야 할 것이다. 나중에 민아는 선생님께 수업 진도를 **더 느리게 요청**했고 선생님은 **몇 가지 개념 먼저 설명**한 다음 민아가 **이해했다는 것을 확인하면 다음 개념으로** 넘어가기로 했다.
- 흐름 제어 원리도 이 예시와 비슷하다. 송신자 측에 한 번에 **수신자한테 보낼 수 있는 최대 속도**를 알려주면 그 속도를 반영해 수신자가 수용할 수 있는 만큼만 데이터를 보내서 **데이터 손실(frame loss)을 줄인다.**
- 수신 버퍼는 데이터를 더 받을 수 있는 용량을 알려준다. 수신 측 버퍼가 가득 차면 더이상 송신 측에서 데이터를 보내지 않도록 한다.

> **Frame**
> 네크워크에서 메시지의 작은 부분. 데이터 식별을 도우며 디코딩 및 해석 방식을 결정할 수 있도록 돕는다.

### 흐름 제어 방법 - Sliding Window Protocol

- 가장 많이 쓰이는 흐름 제어 방법 중 하나


<img src="https://velog.velcdn.com/images/urjimyu/post/bb82e775-1880-4870-a977-cae65949d517/image.png" width="400" height="300"/>

> **Reciever window 수신 윈도우**
> 현재 수신 가능한 수신 버퍼의 크기를 의미한다.
> 윈도우는 TCP 세그먼트 frame의 일부로, 총 길이 16비트이다.
> 수신 측에서 윈도우 크기를 정해서 각 ACK 메시지마다 윈도우 크기를 함께 보내준다.

> **Sender window 송신 윈도우**
> 송신 단에 있으면 송신 윈도우라고 한다.
> 네트워크 환경에 따라 동적으로 크기가 정해진다.
> `송신 윈도우 = Min(혼잡 윈도우, 수신 윈도우 여유 크기)`

- 수신 윈도우와 송신 윈도우 모두 크기는 변할 수 있다.

<img src="https://velog.velcdn.com/images/urjimyu/post/eedf713a-a63b-4ed9-8cdc-6c3619922d8c/image.png" width="400" height="300"/>


- 윈도우 크기를 가지고 TCP는 ACK 없이 최대 몇 개의 데이터를 송신할 수 있는지 계산한다. 윈도우 크기가 0이면 0보다 커질 때까지 TCP는 데이터 전송을 멈춘다.

<img src="https://velog.velcdn.com/images/urjimyu/post/f2568f23-6efb-4ea2-8550-50b218f61a4a/image.png" width="300" height="150"/>


1. Opening Window 윈도우 열기
   - 보낼 수 있는 만큼 데이터를 모두 보낸고 수신 측으로부터 ACK를 받으면 더 많은 패킷을 보낼 수 있도록 윈도우 크기를 증가시킨다.
2. Closing Window 윈도우 닫기
   - 수신 윈도우가 가득 차 더 이상 세그먼트 수신이 불가할 때 송신 윈도우가 더이상 송신하지 않도록 하는 것

<img src="https://velog.velcdn.com/images/urjimyu/post/a589127f-bb1e-4ff5-b225-401538d86f39/image.png" width="300" height="200"/>

- 위 사진과 같은 방식으로 수신 측에서 더 받을 수 있는 데이터 양을 계산해서 보내주고, `receiveWindow=0`이 되면 윈도우를 닫는다.

⇒ `receiveWindow=0` 이후 수신자가 ACK를 안 보내면 발신자는 계속 전송 시작하기를 기다리고 수신자는 데이터가 더 오기를 기다리는 데드락(교착 상태) 위험이 있으므로 receiveWindow가 0일 때마다 TCP는 주기적으로 작은 패킷을 수신자에게 보내는 영구적인 타이머(Persist Timer)를 작동시킨다. 이를 WindowProbe라고도 한다.

3.  Shrinking Window 윈도우 축소


    - 바이트를 빨리 읽어들이지 못하면 윈도우 크기가 축소하기도 한다.

## 혼잡 제어

<img src="https://velog.velcdn.com/images/urjimyu/post/412f00b0-860a-41e2-a6d1-7cf189de792a/image.png" width="300" height="200"/>

- 혼잡은 특정 링크에 제어 가능한 양보다 많은 패킷이 몰리는 경우 발생한다. 너무 많은 패킷들이 몰리면 많은 양의 패킷이 손실된다.
- TCP의 문제 중 하나는 바로 송신자들이 특정 경로의 사용 가능한 대역폭을 알지 못한다는 점이다. 그래서 송신 측에서 왕복 시간마다 전송하는 패킷 양을 계속 늘려서 패킷이 얼마나 손실되었는지를 통해 대역폭을 추측하는 수밖에 없다.

### 혼잡 제어 방법

**1. Tahoe/Reno(80/90년대)**

<img src="https://velog.velcdn.com/images/urjimyu/post/14a19632-8b48-49d1-bcea-bb401d3adc0e/image.png" width="400" height="300"/>

- 특정 임계값에 도달할 때까지 혼잡 윈도우 사이즈 기하급수적으로 늘리는 방식이다. 임계값 이후에는 선형적으로 늘린다.
- 늘리다가 데이터 손실을 겪으면 윈도우 크기를 급격하게 줄이고 “slow start” 모드에 돌입해 천천히 임계값에 도달할 때까지 다시 윈도우 크기를 늘린다.
  **2. CUBIC** - 인터넷의 발전으로 더 대역폭이 높고 긴 네트워크가 나왔고, 따라서 TCP 송신 측에서는 훨씬 더 크기가 큰 혼잡 윈도우를 전송해야 한다. (기존의 방식은 대역폭을 찾기까지 너무 오래 걸린다) - 이런 요즘의 네트워크에 더 좋은 성능을 보이는 알고리즘이 CUBIC으로, 빠르게 대역폭을 찾으면서도 1) 네트워크 과부하를 유발하지 않고 2)다른 송신자들로부터 사용 가능한 대역폭을 많이 뺏지 않는 방식이다.

<img src="https://velog.velcdn.com/images/urjimyu/post/e94f88f5-0804-4f33-8200-d530f4baaf65/image.png" width="200" height="300"/>

- x가 작을수로 t 함수가 급증하고, 특정 지점(변곡점)에 가까워지면 증가 속도가 줄어들다가 그 지점 이후에는 또다시 급증하는 모양을 보인다. 이 모양을 활용한 것이 CUBIC.
- 마지막 패킷 손실을 기점으로 혼잡 윈도우 크기를 키우는데, 이때 변곡점을 마지막 손실 당시의 혼잡 윈도우 크기로 설정한다. 이후 급증 → 지난 손실 때 크기 쯤에서 더이상 데이터 손실을 겪지 않으면 천천히 증가 → 이후 다시 급증
- 즉 좌측의 오목한 부분을 지나며 지난번 데이터 손실 지점까지 따라잡고 아직 데이터 손실이 없다면 빠른 대역폭 발견을 위해 빠르게 증가시키며 탐색하는 것이라고 이해할 수 있다.
